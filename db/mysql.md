# podman启动

## podman-compose

- `./podman_compose.py -f compose.yaml up -d`

```yaml
version: '3.8'
services:
  mysql:
    container_name: ly_mysql8
    image: mysql:8.4.5
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: 111111
      MYSQL_DATABASE: mysql
      MYSQL_USER: mysql
      MYSQL_PASSWORD: 111111
    ports:
      - "8562:3306"
    volumes:
    #   - ~/data/mysql8/conf:/etc/mysql/conf.d
      - ~/data/mysql8/data:/var/lib/mysql
    command: 
      - "--character-set-server=utf8mb4"
      - "--collation-server=utf8mb4_unicode_ci"

# 配置会自动将本地同目录映射到容器同目录: - mysql8_data:/var/lib/mysql
# volumes:
#   mysql8_data:
#   pg17_data:
```

# 字段类型

## varchar

字段值 + 字段长度

# 索引

MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。可以得到索引的本质： **索引是数据结构** 。

- InnoDB存储引擎支持以下几种：B+树索引（关键）、全文索引、哈希索引

## 为什么HashMap不适合做索引？

![](/db/img/mysql_hash_index.png)

1. hash表只能匹配是否相等，**不能实现范围查找**
2. 当需要按照索引进行**order by**时，hash值没办法支持排序
3. **组合索引**可以支持部分索引查询，如(a,b,c)的组合索引，查询中只用到了a和b也可以查询的，如果使用hash表，组合索引会将几个字段合并hash，没办法支持部分索引
4. 当数据量很大时，**hash冲突**的概率也会非常大

## B+Tree

B+树索引就是传统意义上的索引，这是目前关系型数据库系统中查找最常用和最为有效的索引。B+树索引的构造类似于二叉树，根据键值（Key Value）快速找到数据。注意B+树中的B不是代表二叉(binary)，而是代表平衡(balance)，因为B+树是从最早的平衡二叉树演化而来，但是B+树不是一个二叉树。

为什么不用B树

1. 索引的时候 B树数据在枝干上，会返回数据, 这样每次磁盘I/O读取的时候(4k) 会返回更少的索引
2. B+树 数据在叶子上 且是排序的， 范围查找会更方便

## 聚集(聚簇)索引: 主键 叶子存行数据

InnoDB中使用了聚集索引，就是将表的**主键**用来构造一棵B+树，并且将整张表的行记录**数据存放在该B+树的叶子节点中**。也就是所谓的**索引即数据，数据即索引**。由于聚集索引是利用表的主键构建的，所以每张表只能拥有一个聚集索引。

如果没有定义主键，MySQL会使用唯一性索引，没有唯一性索引，MySQL也会创建一个隐含列RowID来做主键，然后用这个主键来建立聚集索引。

![](/db/img/mysql_innodb_index.png)

优点: 
- 通过过聚集索引能获取完整的整行数据。
- 对于主键的排序查找和范围查找速度非常快。

## 辅助(二级)索引: 非主键 叶子存主键值

聚簇索引与主键是强关联的， 为**其他字段**建立的索引， 被称为辅助索引(Secondary Index，也称二级索引、非聚集索引)， 每建立一个索引，就有一颗B+树。

对于辅助索引，叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签(bookmark), 存放**相应行数据的聚集索引键**。

![](/db/img/mysql_innodb_index2.png)

## 回表

当通过辅助索引来寻找数据时，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引（聚集索引）来找到一个完整的行记录。这个过程也被称为 **回表** 。 也就是根据辅助索引的值查询一条完整的用户记录需要使用到2棵B+树（一次辅助索引，一次聚集索引）。

![](/db/img/mysql_innodb_index3.png)

为什么需要回表而不是把数据放到辅助索引叶子上。 
1. 这样数据会存储多份， 占用大量磁盘
2. 修改需要把所有辅助索引数据都操作一遍， 性能非常低下

**结论**

回表的记录越少，性能提升就越高。 回表的记录越多，使用二级索引的性能就越低。 甚至让某些查询宁愿使用全表扫描也不使用二级索引。

全表扫描 与 二级索引(+回表) 如何选择？ 这是**查询优化器**的工作，查询优化器会事先对表中的记录计算一些**统计数据**，然后再利用这些统计数据根据查询的条件来**计算一下需要回表的记录数**，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用二级索引(+回表)的方式。

## 联合(复合)索引: 多字段

将表上的**多个列**组合起来进行索引我们称之为联合索引或者复合索引, 联合索引只会创建一颗B+树

![](/db/img/mysql_innodb_index4.png)

1. 先把各个记录按照note列进行排序。
2. 在记录的note列相同的情况下，采用b列进行排序
3. 这就是产生**最佳左前缀法则**的原因

如果索引包含 (时间, 数字, varchar)， 树上节点是什么样的， 是如何排序的:
`[指针] (2023-01-01,100,"apple") [指针] (2023-01-01,100,"banana") [指针] (2023-01-01,200,"apple") [指针] (2023-01-02,100,"cherry") [指针]`

## 覆盖索引: 不是索引 sql涉及字段都在索引上

从辅助索引中就可以得到查询的记录， **查询sql涉及的字段都在索引上，需要的字段被索引覆盖**， 而不需要查询聚集索引中的记录， 即**不需要回表**。

使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。所以，覆盖索引并不是索引类型的一种。


# 优化sql

1. 减少索引 减少回表