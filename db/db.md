# 开始

- 数据库排名: https://db-engines.com/en/

## 概念

| 类型 | 全称                       | 中文名称  | 功能                            | 示例                |
| ---- | -------------------------- | ------- | ------------------------------- | ------------------- |
| DML  | Data Manipulation Language | 数据操作语言 | 操作数据（增删改查）            | UPDATE, INSERT      |
| DDL  | Data Definition Language   | 数据定义语言 | 定义/修改数据结构（表、索引等） | CREATE TABLE, ALTER |
| DCL  | Data Control Language      | 数据控制语言 | 权限控制                        | GRANT, REVOKE       |

# 六种范式

- 范式来自英文Normal Form，简称NF。**一张数据表的表结构所符合的某种设计标准的级别**
- 目前关系数据库有六种范式
    - 第一范式（1NF）： 关系型数据库最基本要求
    - 第二范式（2NF）
    - 第三范式（3NF）： **一般来说，数据库只需满足此范式就行了**
    - 巴斯-科德范式（BCNF）
    - 第四范式（4NF）
    - 第五范式（5NF，完美范式）。
    - 每一个范式都是在前一种范式的基础上进一步规范完成
    - ![](/db/img/fanshirel.png)


## 第一范式: 数据项不可分

定义： 属于第一范式关系的所有属性都不可再分，即数据项不可分。

理解：第一范式强调数据表的**原子性**，是其他范式的基础。一张表有一个name-age列，这个列具有两个属性，一个name,一个 age，所以不符合第一范式，我们把它拆分成两列name和age，这张表就符合第一范式关系。

| id   | name-age |
| ---- | -------- |
| 1    | 张三-18  |
| 2    | 李四-23  |

↓↓↓

| id   | name | age  |
| ---- | ---- | ---- |
| 1    | 张三 | 18   |
| 2    | 李四 | 23   |

**第一范式详细的要求如下：**

1. 每一列属性都是不可再分的属性值，确保每一列的原子性；
2. 两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据；
3. 单一属性的列为基本数据类型构成；
4. 设计出来的表都是简单的二维表。

## 第二范式: 实体属性完全依赖主关键字

1. 先满足第一范式
2. 要求实体的属性完全依赖于主关键字。

这张表就不符合第二范式: product_id并不是完全依赖id
| id（订单编号 主键）| order_time          | **product_id** |
| -------------- | ------------------- | ---------- |
| 1              | 2024-01-25 12:12:12 | **1**          |
| 1              | 2024-01-25 12:12:12 | **2**          |

- 所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。
- 将上表拆分就符合， 如下

订单表
| id（订单编号 主键）| order_time         |
| -------------- | ------------------- |
| 1              | 2024-01-25 12:12:12 |
| 1              | 2024-01-25 12:12:12 |

关联表
| op_id（流水号 主键） | order_id | product_id |
| --------------- | -------- | ---------- |
| 1               | 1        | 1          |
| 2               | 1        | 2          |

## 第三范式: 不包含其他表的非主键

1. 满足第二范式
2. 要求一个数据库表中**不包含已在其它表中包含的非主关键字**信息，即数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。

此表中 product_name 是产品表的非主关键字， 如果产品表中的名称变了呢？ 所以不符合第三范式

| id   | order_time          | product_id | **product_name** |
| ---- | ------------------- | ---------- | ------------ |
| 1    | 2024-01-25 12:12:12 | 1          | **机械键盘**     |
| 2    | 2024-02-25 12:12:12 | 2          | **蓝牙鼠标**     |

修改一下， 就符合第三范式， 如下
| id   | order_time          | product_id |
| ---- | ------------------- | ---------- |
| 1    | 2024-01-25 12:12:12 | 1          |
| 2    | 2024-02-25 12:12:12 | 2          |

## 范式化一定好吗? (违反)反范式化设计

完全符合范式化的设计真的完美无缺吗？很明显在实际的业务查询中会大量存在着表的关联查询，而表设计都做成了范式化设计（甚至很高的范式），大量的表关联很多的时候非常影响查询的性能。

1. 为了性能和读取效率而适当的违反对数据库设计范式的要求
2. 为了查询的性能，允许存在部分（少量）冗余数据

**换句话来说反范式化就是使用空间来换取时间。**

|              | 范式设计 | 反范式设计 |
| ------------ | :------: | :--------: |
| 更新操作     |    快    |     慢     |
| 数据重复度   |    低    |     高     |
| 内存占用     |    小    |     大     |
| 查询表关联   |    多    |     少     |
| 查询索引命中 |   较少   |    更多    |

1. 范式化的更新操作通常比反范式化要快（字段较少）。
2. 当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。
3. 范式化的表通常更小，所以占据的内存更少。
4. 范式化设计的缺点是通常需要关联，稍微复杂一些的查询语句在符合范式的表上都可能需要至少一次关联，也许更多。
5. 复杂一些的查询语句也可能使一些索引策略无效。例如，范式化可能将列存放在不同的表中，而这些列如果在一个表中本可以属于同一个索引。

### 计数器表设计

计数器表在Web应用中很常见。比如网站点击数、用户的朋友数、文件下载次数等。对于高并发下的处理，首先可以创建一张独立的表存储计数器，这样可使计数器表小且快，并且可以使用一些更高级的技巧。

| id   | count_name | count |
| ---- | ---------- | ----- |
| 1    | check      | 80    |

```sql
-- 这条sql会给数据加一条互斥锁， 如果在高并发场景下， 串行执行会严重限制系统并发能力
update count set count=count+1 where id = 1;
```

修改表结构使用**id+slot联合索引**， 如下 这样更新时即可实现3并发， 如果继续加slot...
| id   | count_name | slot | count |
| ---- | ---------- | ---- | ----- |
| 1    | check      | 1    | 80    |
| 1    | check      | 2    | 78    |
| 1    | check      | 3    | 100   |

```sql
update count set count=count+1 where id = 1 and slot = 1;
update count set count=count+1 where id = 1 and slot = 2;
update count set count=count+1 where id = 1 and slot = 3;
```

# 字段优化

## 基本原则

### 1. 更小的通常更好

更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少。

比如：是有一个类型既可以用字符串也可以使用整型，**优先选择整型**。因为字符串牵涉到了字符集及校对规则等。

### 2. 简单就好

简单数据类型的操作通常需要更少的CPU周期。例如，整型比字符操作代价更低，因为字符集和校对规则(排序规则)使字符比较比整型比较更复杂。比如应该使用MySQL内建的类型而不是字符串来存储日期和时间。

### 3. 尽量避免NULL

性能提升不大

通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。

如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节。

通常把可为NULL的列改为NOT NULL带来的性能提升比较小，所以（调优时）没有必要首先在现有schema中查找并修改掉这种情况，除非确定这会导致问题。但是，如果计划在列上建索引，就应该尽量避免设计成可为NULL的列。

# 命名规范

1. 可读性原则

数据库、表、字段的命名要遵守可读性原则，尽可能少使用或者不使用缩写。

对象的名字应该能够描述它所表示的对象。例如：表的名称应该能够体现表中存储的数据内容，最好是遵循“业务名称_表的作用”；对于存储过程存储过程应该能够体现存储过程的功能。库名与应用名称尽量一致。

表达是与否概念的字段，应该使用is_xxx的方式命名，数据类型是unsigned tinyint（1表示是，0表示否）。

2. 表名、字段名必须使用小写字母或数字

禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。

说明：MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。

3. 表名不使用复数名词

4. 数据库、表、字段的命名禁用保留字，如desc、range、match之类

6. 主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名。

# 事物 (DML特性)

DML: insert、update 和 delete语句

## 四个特性 ACID

### 1. 原子性 Atomicity

- 一个原子事务要么完整执行,要么干脆不执行。这意味着,工作单元中的每项任务都必须正确执行。如果有任一任务执行失败,则整个工作单元或事务就会被终止。即此前对数据所作的任何修改都将被撤销。如果所有任务都被成功执行,事务就会被提交,即对数据所作的修改将会是永久性的

### 2. 一致性 Consistency **最关键** 

- 一致性代表了底层数据存储的完整性。它必须由事务系统和应用开发人员共同来保证。事务系统通过保证事务的原子性,隔离性和持久性来满足这一要求；应用开发人员则需要保证数据库有适当的约束(主键,引用完整性等),并且工作单元中所实现的业务逻輯不会导致数据的不一致（即,数据预期所表达的现实业务情况不相一致）。
- 例如，在一次转账过程中，从某一账户中扣除的金额必须与另一账户存入的金额相等。支付宝账号100你读到余额要取,有人向你转100但是事物没提交（这时候你读到的余额应该是100,而不是200）这种就是一致性

### 3. 隔离性 isolation

- 隔离性意味着事务必须在不干扰其他进程或事务的前提下独立执行。换言之,在事务或工作单元执行完毕之前,其所访问的数据不能受系统其他部分的影响。
- 严格隔离会导致效率降低

#### 隔离级别

级别越高(向下)， 数据越安全

| 隔离级别 | 隔离级别         | 脏读 | 不可重复度 | 幻读 |
| :------- | :--------------- | ---- | ---------- | ---- |
| 读未提交 | read uncommitted | √    | √          | √    |
| 读已提交 | read commited   | ×    | √          | √    |
| 可重复读 | repeatable read  | ×    | ×          | √    |
| 序列化   | Serializable     | ×    | ×          | ×    |

#### 事务并发引起的问题

脏读 > 不可重复读 > 幻读

| 问题       | 描述                                                         |
| ---------- | :----------------------------------------------------------- |
| 脏读       | **修改**的数据未提交就被读出来了                               |
| 不可重复读 | 同一事务， 多次查询同一数据（之间有另一事务**修改**了数据）， **结果**不一致 |
| 幻读       | 同一事务， 多次查询同一条件（之间有另一事务**插入**了数据）， **结果集**不一致 |

### 4. 持久性 Durability

- 表示在某个事务的执行过程中,对数据所作的所有改动都必须在事务成功结束前保存至某种物理存储设备。这样可以保证,所作的修改在任何系统瘫痪时不至于丢失
- 即 持久化到磁盘 或 存储介质中

# 锁 (DML特性)

- 并发 数据不一致的问题 需要加锁
- 粒度： 库、表、行
- 粒度越小 效率越高
- 实际工作环境中，大部分操作都是行级锁